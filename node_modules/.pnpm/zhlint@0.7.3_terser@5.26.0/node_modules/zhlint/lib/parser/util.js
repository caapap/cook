"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleErrors = exports.getHyperContentType = exports.isShorthand = exports.getHyperMarkMap = exports.getPreviousToken = exports.getConnectingSpaceLength = exports.appendValue = exports.initNewContent = exports.finalizeCurrentGroup = exports.initNewGroup = exports.finalizeCurrentMark = exports.addBracketToken = exports.initNewMark = exports.addRawContent = exports.addHyperToken = exports.finalizeCurrentToken = exports.finalizeLastToken = exports.initNewStatus = exports.handleLetter = exports.handlePunctuation = void 0;
const report_1 = require("../report");
const char_1 = require("./char");
const messages_1 = require("./messages");
const types_1 = require("./types");
const handlePunctuation = (i, char, type, status) => {
    // end the last unfinished token
    (0, exports.finalizeLastToken)(status, i);
    // check the current token type
    // - start of a mark: start an unfinished mark
    // - end of a mark: end the current unfinished mark
    // - neutral quotation: start/end a group by pairing the last unfinished group
    // - left quotation: start a new unfinished group
    // - right quotation: end the current unfinished group
    // - other punctuation: add and end the current token
    if ((0, types_1.isBracketType)(type)) {
        if (types_1.BRACKET_CHAR_SET.left.indexOf(char) >= 0) {
            // push (save) the current unfinished mark if have
            (0, exports.initNewMark)(status, i, char);
            // generate a new token and mark it as a mark punctuation by left
            // and finish the token
            (0, exports.addBracketToken)(status, i, char, types_1.MarkSideType.LEFT);
        }
        else if (types_1.BRACKET_CHAR_SET.right.indexOf(char) >= 0) {
            if (!status.lastMark || !status.lastMark.startValue) {
                addUnmatchedToken(status, i, char);
                addError(status, i, messages_1.BRACKET_NOT_OPEN);
            }
            else {
                // generate token as a punctuation
                (0, exports.addBracketToken)(status, i, char, types_1.MarkSideType.RIGHT);
                // end the last unfinished mark
                // and pop the previous one if exists
                (0, exports.finalizeCurrentMark)(status, i, char);
            }
        }
        return;
    }
    if ((0, types_1.isQuotationType)(type)) {
        if (types_1.QUOTATION_CHAR_SET.neutral.indexOf(char) >= 0) {
            // - end the last unfinished group
            // - start a new group
            if (status.lastGroup && char === status.lastGroup.startValue) {
                (0, exports.finalizeCurrentGroup)(status, i, char);
            }
            else {
                (0, exports.initNewGroup)(status, i, char);
            }
        }
        else if (types_1.QUOTATION_CHAR_SET.left.indexOf(char) >= 0) {
            (0, exports.initNewGroup)(status, i, char);
        }
        else if (types_1.QUOTATION_CHAR_SET.right.indexOf(char) >= 0) {
            if (!status.lastGroup || !status.lastGroup.startValue) {
                addUnmatchedToken(status, i, char);
                addError(status, i, messages_1.QUOTE_NOT_OPEN);
            }
            else {
                (0, exports.finalizeCurrentGroup)(status, i, char);
            }
        }
        return;
    }
    addSinglePunctuationToken(status, i, char, type);
};
exports.handlePunctuation = handlePunctuation;
const handleLetter = (i, char, type, status) => {
    // check if type changed and last token unfinished
    // - create new token in the current group
    // - append into current unfinished token
    if (status.lastToken) {
        if (status.lastToken.type !== type) {
            (0, exports.finalizeLastToken)(status, i);
            (0, exports.initNewContent)(status, i, char, type);
        }
        else {
            (0, exports.appendValue)(status, char);
        }
    }
    else {
        (0, exports.initNewContent)(status, i, char, type);
    }
};
exports.handleLetter = handleLetter;
// status
const initNewStatus = (str, hyperMarks) => {
    const tokens = [];
    Object.assign(tokens, {
        type: types_1.GroupTokenType.GROUP,
        index: 0,
        spaceAfter: '',
        startIndex: 0,
        endIndex: str.length - 1,
        startValue: '',
        endValue: '',
        innerSpaceBefore: ''
    });
    const status = {
        lastToken: undefined,
        lastGroup: tokens,
        lastMark: undefined,
        tokens,
        marks: [...hyperMarks],
        groups: [],
        markStack: [],
        groupStack: [],
        errors: []
    };
    return status;
};
exports.initNewStatus = initNewStatus;
// finalize token
const finalizeLastToken = (status, index) => {
    if (status.lastToken) {
        // the lastToken.index is not the current index anymore
        status.lastToken.length = index - status.lastToken.index;
        status.lastGroup && status.lastGroup.push(status.lastToken);
        status.lastToken = undefined;
    }
};
exports.finalizeLastToken = finalizeLastToken;
const finalizeCurrentToken = (status, token) => {
    status.lastGroup && status.lastGroup.push(token);
    status.lastToken = undefined;
};
exports.finalizeCurrentToken = finalizeCurrentToken;
// hyper marks
const markTypeToTokenType = (type) => {
    switch (type) {
        case types_1.MarkType.HYPER:
            return types_1.HyperTokenType.HYPER_MARK;
        case types_1.MarkType.BRACKETS:
            return types_1.HyperTokenType.BRACKET_MARK;
        case types_1.MarkType.RAW:
            // technically never since MarkType.RAW should go to addRawContent()
            return types_1.HyperTokenType.INDETERMINATED;
    }
};
const addHyperToken = (status, index, mark, value, markSide) => {
    const token = {
        type: markTypeToTokenType(mark.type),
        index,
        length: value.length,
        value: value,
        spaceAfter: '',
        mark: mark,
        markSide
    };
    (0, exports.finalizeCurrentToken)(status, token);
};
exports.addHyperToken = addHyperToken;
const addRawContent = (status, index, value) => {
    const token = {
        type: (0, exports.getHyperContentType)(value),
        index,
        length: value.length,
        value: value,
        spaceAfter: '' // to be finalized
    };
    (0, exports.finalizeCurrentToken)(status, token);
};
exports.addRawContent = addRawContent;
// bracket marks
const initNewMark = (status, index, char, type = types_1.MarkType.BRACKETS) => {
    if (status.lastMark) {
        status.markStack.push(status.lastMark);
        status.lastMark = undefined;
    }
    const mark = {
        type,
        startIndex: index,
        startValue: char,
        endIndex: -1,
        endValue: '' // to be finalized
    };
    status.marks.push(mark);
    status.lastMark = mark;
};
exports.initNewMark = initNewMark;
const addBracketToken = (status, index, char, markSide) => {
    const token = {
        type: types_1.HyperTokenType.BRACKET_MARK,
        index,
        length: 1,
        value: char,
        spaceAfter: '',
        mark: status.lastMark,
        markSide
    };
    (0, exports.finalizeCurrentToken)(status, token);
};
exports.addBracketToken = addBracketToken;
const finalizeCurrentMark = (status, index, char) => {
    if (!status.lastMark) {
        return;
    }
    status.lastMark.endIndex = index;
    status.lastMark.endValue = char;
    if (status.markStack.length > 0) {
        status.lastMark = status.markStack.pop();
    }
    else {
        status.lastMark = undefined;
    }
};
exports.finalizeCurrentMark = finalizeCurrentMark;
// normal punctuation
const addSinglePunctuationToken = (status, index, char, type) => {
    const token = {
        type,
        index,
        length: 1,
        value: char,
        spaceAfter: '' // to be finalized
    };
    (0, exports.finalizeCurrentToken)(status, token);
};
const addUnmatchedToken = (status, i, char) => {
    const token = {
        type: types_1.HyperTokenType.UNMATCHED,
        index: i,
        length: 1,
        value: char,
        spaceAfter: ''
    };
    (0, exports.finalizeCurrentToken)(status, token);
};
// group
const initNewGroup = (status, index, char) => {
    status.lastGroup && status.groupStack.push(status.lastGroup);
    const lastGroup = [];
    Object.assign(lastGroup, {
        type: types_1.GroupTokenType.GROUP,
        index,
        spaceAfter: '',
        startIndex: index,
        startValue: char,
        endIndex: -1,
        endValue: '',
        innerSpaceBefore: '' // to be finalized
    });
    // TODO: previous group in stack
    status.groupStack[status.groupStack.length - 1].push(lastGroup);
    status.lastGroup = lastGroup;
    status.groups.push(lastGroup);
};
exports.initNewGroup = initNewGroup;
const finalizeCurrentGroup = (status, index, char) => {
    if (status.lastGroup) {
        // index, length, value
        status.lastGroup.endIndex = index;
        status.lastGroup.endValue = char;
    }
    if (status.groupStack.length > 0) {
        status.lastGroup = status.groupStack.pop();
    }
    else {
        status.lastGroup = undefined;
    }
};
exports.finalizeCurrentGroup = finalizeCurrentGroup;
// general content
const initNewContent = (status, index, char, type) => {
    status.lastToken = {
        type,
        index,
        length: 1,
        value: char,
        spaceAfter: '' // to be finalized
    };
};
exports.initNewContent = initNewContent;
const appendValue = (status, char) => {
    if (status.lastToken) {
        status.lastToken.value += char;
        status.lastToken.length++;
    }
};
exports.appendValue = appendValue;
// others
/**
 * Get the length of connecting spaces from a certain index
 */
const getConnectingSpaceLength = (str, start) => {
    // not even a space
    if ((0, char_1.checkCharType)(str[start]) !== types_1.CharType.SPACE) {
        return 0;
    }
    // find the next non-space char
    for (let i = start + 1; i < str.length; i++) {
        const char = str[i];
        const type = (0, char_1.checkCharType)(char);
        if (type !== types_1.CharType.SPACE) {
            return i - start;
        }
    }
    // space till the end
    return str.length - start;
};
exports.getConnectingSpaceLength = getConnectingSpaceLength;
const getPreviousToken = (status) => {
    if (status.lastGroup) {
        return status.lastGroup[status.lastGroup.length - 1];
    }
};
exports.getPreviousToken = getPreviousToken;
const getHyperMarkMap = (hyperMarks) => {
    const hyperMarkMap = {};
    hyperMarks.forEach((mark) => {
        hyperMarkMap[mark.startIndex] = mark;
        if (mark.type !== types_1.MarkType.RAW) {
            hyperMarkMap[mark.endIndex] = mark;
        }
    });
    return hyperMarkMap;
};
exports.getHyperMarkMap = getHyperMarkMap;
const isShorthand = (str, status, index, char) => {
    if (types_1.SHORTHAND_CHARS.indexOf(char) < 0) {
        return false;
    }
    if (!status.lastToken || status.lastToken.type !== types_1.CharType.WESTERN_LETTER) {
        return false;
    }
    const nextChar = str[index + 1];
    const nextType = (0, char_1.checkCharType)(nextChar);
    if (nextType === types_1.CharType.WESTERN_LETTER || nextType === types_1.CharType.SPACE) {
        if (!status.lastGroup) {
            return true;
        }
        if (status.lastGroup.startValue !== types_1.SHORTHAND_PAIR_SET[char]) {
            return true;
        }
    }
    return false;
};
exports.isShorthand = isShorthand;
const getHyperContentType = (content) => {
    if (content.match(/\n/)) {
        // Usually it's hexo custom containers.
        return types_1.HyperTokenType.HYPER_CONTENT;
    }
    if (content.match(/^<code.*>.*<\/code.*>$/)) {
        // Usually it's <code>...</code>.
        return types_1.HyperTokenType.CODE_CONTENT;
    }
    if (content.match(/^<.+>$/)) {
        // Usually it's other HTML tags.
        return types_1.HyperTokenType.HYPER_CONTENT;
    }
    // Usually it's `...`.
    return types_1.HyperTokenType.CODE_CONTENT;
};
exports.getHyperContentType = getHyperContentType;
// error handling
const addError = (status, index, message) => {
    status.errors.push({
        name: '',
        index,
        length: 0,
        message,
        target: report_1.ValidationTarget.VALUE
    });
};
const handleErrors = (status) => {
    // record an error if the last mark not fully resolved
    const lastMark = status.lastMark;
    if (lastMark && lastMark.type === types_1.MarkType.BRACKETS && !lastMark.endValue) {
        addError(status, lastMark.startIndex, messages_1.BRACKET_NOT_CLOSED);
    }
    // record an error if `markStack` not fully resolved
    if (status.markStack.length > 0) {
        status.markStack.forEach((mark) => {
            if (mark !== lastMark) {
                addError(status, mark.startIndex, messages_1.BRACKET_NOT_CLOSED);
            }
        });
    }
    // record an error if the last group not fully resolved
    const lastGroup = status.lastGroup;
    if (lastGroup && lastGroup.startValue && !lastGroup.endValue) {
        addError(status, lastGroup.startIndex, messages_1.QUOTE_NOT_CLOSED);
    }
    // record an error if `groupStack` not fully resolved
    if (status.groupStack.length > 0) {
        status.groupStack.forEach((group) => {
            if (group !== lastGroup && group.startValue && !group.endValue) {
                addError(status, group.startIndex, messages_1.QUOTE_NOT_CLOSED);
            }
        });
    }
};
exports.handleErrors = handleErrors;
