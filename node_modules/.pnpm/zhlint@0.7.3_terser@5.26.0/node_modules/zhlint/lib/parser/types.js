"use strict";
/**
 * @fileOverview
 *
 * This file contains the types for the parser.
 *
 * - Chars
 * - Pairs
 * - Marks
 * - Tokens
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isVisibilityUnknownType = exports.isInvisibleType = exports.isVisibleType = exports.isNonCodeVisibleType = exports.isFullwidthType = exports.isFullwidthPunctuationType = exports.isHalfwidthType = exports.isHalfwidthPunctuationType = exports.isPunctuationType = exports.isSinglePunctuationType = exports.isOtherPunctuationType = exports.isBracketType = exports.isQuotationType = exports.isPauseOrStopType = exports.isLetterType = exports.getFullwidthTokenType = exports.getHalfwidthTokenType = exports.GroupTokenType = exports.HyperTokenType = exports.isRawMark = exports.MarkSideType = exports.MarkType = exports.isFullwidthPair = exports.SHORTHAND_PAIR_SET = exports.SHORTHAND_CHARS = exports.QUOTATION_CHAR_SET = exports.BRACKET_CHAR_SET = exports.CharType = void 0;
// Char
var CharType;
(function (CharType) {
    CharType["EMPTY"] = "empty";
    CharType["SPACE"] = "space";
    CharType["WESTERN_LETTER"] = "western-letter";
    CharType["CJK_CHAR"] = "cjk-char";
    // periods, commas, secondary commas, colons, semicolons, exclamation marks, question marks, etc.
    CharType["HALFWIDTH_PAUSE_OR_STOP"] = "halfwidth-pause-or-stop";
    CharType["FULLWIDTH_PAUSE_OR_STOP"] = "fullwidth-pause-or-stop";
    // single, double, corner, white corner
    // + book title marks
    // left x right
    CharType["HALFWIDTH_QUOTATION"] = "halfwidth-quotation";
    CharType["FULLWIDTH_QUOTATION"] = "fullwidth-quotation";
    // parentheses
    CharType["HALFWIDTH_BRACKET"] = "halfwidth-bracket";
    CharType["FULLWIDTH_BRACKET"] = "fullwidth-bracket";
    // // parenthesis, black lenticular brackets, white lenticular brackets,
    // // square brackets, tortoise shell brackets, curly brackets
    // // left x right
    // PARENTHESIS = 'parenthesis',
    // // double angle brackets, angle brackets
    // // left x right
    // BOOK_TITLE_MARK = 'book-title',
    // dashes, ellipsis, connector marks, interpuncts, proper noun marks, solidi, etc.
    CharType["HALFWIDTH_OTHER_PUNCTUATION"] = "halfwidth-other-punctuation";
    CharType["FULLWIDTH_OTHER_PUNCTUATION"] = "fullwidth-other-punctuation";
    // // ⁈, ⁇, ‼, ⁉
    // SPECIAL_PUNCTUATION_MARK = 'special-punctuation',
    CharType["UNKNOWN"] = "unknown";
})(CharType = exports.CharType || (exports.CharType = {}));
exports.BRACKET_CHAR_SET = {
    left: '([{（〔［｛',
    right: ')]}）〕］｝'
};
exports.QUOTATION_CHAR_SET = {
    left: `“‘《〈『「【〖`,
    right: `”’》〉』」】〗`,
    neutral: `'"`
};
exports.SHORTHAND_CHARS = `'’`;
exports.SHORTHAND_PAIR_SET = {
    [`'`]: `'`,
    [`’`]: `‘`
};
const FULLWIDTH_PAIRS = `“”‘’（）〔〕［］｛｝《》〈〉「」『』【】〖〗`;
const isFullwidthPair = (str) => FULLWIDTH_PAIRS.indexOf(str) >= 0;
exports.isFullwidthPair = isFullwidthPair;
// Mark
/**
 * Marks are hyper info, including content and wrappers.
 * They are categorized by parsers, not by usage.
 */
var MarkType;
(function (MarkType) {
    /**
     * Brackets
     */
    MarkType["BRACKETS"] = "brackets";
    /**
     * Inline Markdown marks
     */
    MarkType["HYPER"] = "hyper";
    /**
     * - \`xxx\`
     * - &lt;code&gt;xxx&lt;/code&gt;
     * - Hexo/VuePress container
     * - Other html code
     */
    MarkType["RAW"] = "raw";
})(MarkType = exports.MarkType || (exports.MarkType = {}));
var MarkSideType;
(function (MarkSideType) {
    MarkSideType["LEFT"] = "left";
    MarkSideType["RIGHT"] = "right";
})(MarkSideType = exports.MarkSideType || (exports.MarkSideType = {}));
const isRawMark = (mark) => {
    return mark.code !== undefined;
};
exports.isRawMark = isRawMark;
/**
 * TODO: paired html tags should be hyper mark
 */
var HyperTokenType;
(function (HyperTokenType) {
    /**
     * Brackets
     */
    HyperTokenType["BRACKET_MARK"] = "bracket-mark";
    /**
     * Inline Markdown marks
     */
    HyperTokenType["HYPER_MARK"] = "hyper-mark";
    /**
     * - \`xxx\`
     * - &lt;code&gt;xxx&lt;/code&gt;
     */
    HyperTokenType["CODE_CONTENT"] = "code-content";
    /**
     * - Hexo/VuePress container
     * - Other html code
     */
    HyperTokenType["HYPER_CONTENT"] = "hyper-content";
    /**
     * Unpaired brackets/quotations
     */
    HyperTokenType["UNMATCHED"] = "unmatched";
    /**
     * For indeterminate tokens
     */
    HyperTokenType["INDETERMINATED"] = "indeterminated";
})(HyperTokenType = exports.HyperTokenType || (exports.HyperTokenType = {}));
var GroupTokenType;
(function (GroupTokenType) {
    GroupTokenType["GROUP"] = "group";
})(GroupTokenType = exports.GroupTokenType || (exports.GroupTokenType = {}));
const getHalfwidthTokenType = (type) => {
    switch (type) {
        case CharType.CJK_CHAR:
            return CharType.WESTERN_LETTER;
        case CharType.FULLWIDTH_PAUSE_OR_STOP:
            return CharType.HALFWIDTH_PAUSE_OR_STOP;
        case CharType.FULLWIDTH_OTHER_PUNCTUATION:
            return CharType.HALFWIDTH_OTHER_PUNCTUATION;
    }
    return type;
};
exports.getHalfwidthTokenType = getHalfwidthTokenType;
const getFullwidthTokenType = (type) => {
    switch (type) {
        case CharType.WESTERN_LETTER:
            return CharType.CJK_CHAR;
        case CharType.HALFWIDTH_PAUSE_OR_STOP:
            return CharType.FULLWIDTH_PAUSE_OR_STOP;
        case CharType.HALFWIDTH_OTHER_PUNCTUATION:
            return CharType.FULLWIDTH_OTHER_PUNCTUATION;
    }
    return type;
};
exports.getFullwidthTokenType = getFullwidthTokenType;
const isLetterType = (type) => {
    return type === CharType.WESTERN_LETTER || type === CharType.CJK_CHAR;
};
exports.isLetterType = isLetterType;
const isPauseOrStopType = (type) => {
    return (type === CharType.HALFWIDTH_PAUSE_OR_STOP ||
        type === CharType.FULLWIDTH_PAUSE_OR_STOP);
};
exports.isPauseOrStopType = isPauseOrStopType;
const isQuotationType = (type) => {
    return (type === CharType.HALFWIDTH_QUOTATION ||
        type === CharType.FULLWIDTH_QUOTATION);
};
exports.isQuotationType = isQuotationType;
const isBracketType = (type) => {
    return (type === CharType.HALFWIDTH_BRACKET || type === CharType.FULLWIDTH_BRACKET);
};
exports.isBracketType = isBracketType;
const isOtherPunctuationType = (type) => {
    return (type === CharType.HALFWIDTH_OTHER_PUNCTUATION ||
        type === CharType.FULLWIDTH_OTHER_PUNCTUATION);
};
exports.isOtherPunctuationType = isOtherPunctuationType;
const isSinglePunctuationType = (type) => {
    return (0, exports.isPauseOrStopType)(type) || (0, exports.isOtherPunctuationType)(type);
};
exports.isSinglePunctuationType = isSinglePunctuationType;
const isPunctuationType = (type) => {
    return ((0, exports.isPauseOrStopType)(type) ||
        (0, exports.isQuotationType)(type) ||
        (0, exports.isBracketType)(type) ||
        (0, exports.isOtherPunctuationType)(type));
};
exports.isPunctuationType = isPunctuationType;
const isHalfwidthPunctuationType = (type) => {
    return (type === CharType.HALFWIDTH_PAUSE_OR_STOP ||
        type === CharType.HALFWIDTH_QUOTATION ||
        type === CharType.HALFWIDTH_BRACKET ||
        type === CharType.HALFWIDTH_OTHER_PUNCTUATION);
};
exports.isHalfwidthPunctuationType = isHalfwidthPunctuationType;
const isHalfwidthType = (type) => {
    return type === CharType.WESTERN_LETTER || (0, exports.isHalfwidthPunctuationType)(type);
};
exports.isHalfwidthType = isHalfwidthType;
const isFullwidthPunctuationType = (type) => {
    return (type === CharType.FULLWIDTH_PAUSE_OR_STOP ||
        type === CharType.FULLWIDTH_QUOTATION ||
        type === CharType.FULLWIDTH_BRACKET ||
        type === CharType.FULLWIDTH_OTHER_PUNCTUATION);
};
exports.isFullwidthPunctuationType = isFullwidthPunctuationType;
const isFullwidthType = (type) => {
    return type === CharType.CJK_CHAR || (0, exports.isFullwidthPunctuationType)(type);
};
exports.isFullwidthType = isFullwidthType;
const isNonCodeVisibleType = (type) => {
    return ((0, exports.isLetterType)(type) ||
        (0, exports.isSinglePunctuationType)(type) ||
        type === HyperTokenType.BRACKET_MARK ||
        type === GroupTokenType.GROUP);
};
exports.isNonCodeVisibleType = isNonCodeVisibleType;
const isVisibleType = (type) => {
    return (0, exports.isNonCodeVisibleType)(type) || type === HyperTokenType.CODE_CONTENT;
};
exports.isVisibleType = isVisibleType;
const isInvisibleType = (type) => {
    // OTHERS?
    return type === HyperTokenType.HYPER_MARK;
};
exports.isInvisibleType = isInvisibleType;
const isVisibilityUnknownType = (type) => {
    return type === HyperTokenType.HYPER_CONTENT;
};
exports.isVisibilityUnknownType = isVisibilityUnknownType;
