"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toMutableResult = exports.parse = void 0;
const char_1 = require("./char");
const types_1 = require("./types");
const util_1 = require("./util");
/**
 * Parse a string into several tokens.
 * - half-width content x {1,n} (English words)
 * - full-width content x {1,n} (Chinese sentenses without punctuations in between)
 * - half-width punctuation -> halfwidth pause or stop punctuation mark
 * - width-width punctuation -> fullwidth pause or stop punctuation mark
 * - punctuation pair as special marks: brackets -> bracket
 * - punctuation pair as a group: quotations -> quotation or book title mark
 * - -> halfwidth/fullwidth other punctuation mark
 * Besides them there are some special tokens
 * - content-hyper from hyperMarks as input
 * For spaces they would be included as one or multiple successive spaces in
 * - afterSpace after a token or
 * - innerSpaceBefore after the left quotation of a group
 */
const parse = (str, hyperMarks = []) => {
    // init status and hyper marks
    const status = (0, util_1.initNewStatus)(str, hyperMarks);
    const hyperMarkMap = (0, util_1.getHyperMarkMap)(hyperMarks);
    // travel every character in the string
    for (let i = 0; i < str.length; i++) {
        const char = str[i];
        const type = (0, char_1.checkCharType)(char);
        const hyperMark = hyperMarkMap[i];
        // finally get `status.marks` and `status.lastGroup` as the top-level tokens
        // - hyper marks: finalize current token -> add mark
        // - space: end current -> move forward -> record space beside
        // - punctuation: whether start/end a mark or group, or just add a normal one
        // - content: whether start a new one or append into the current one
        if (hyperMark) {
            // end the last unfinished token
            (0, util_1.finalizeLastToken)(status, i);
            // for hyper mark without startValue
            delete hyperMarkMap[i];
            // check the next token
            // - if the mark type is raw
            //   - append next token
            // - else (the mark type is hyper)
            //   - start: append token
            //   - end hyper mark: append token, append mark
            if (hyperMark.type === types_1.MarkType.RAW) {
                (0, util_1.addRawContent)(status, i, str.substring(hyperMark.startIndex, hyperMark.endIndex));
                i = hyperMark.endIndex - 1;
            }
            else {
                if (i === hyperMark.startIndex) {
                    (0, util_1.addHyperToken)(status, i, hyperMark, hyperMark.startValue, types_1.MarkSideType.LEFT);
                    i += hyperMark.startValue.length - 1;
                }
                else if (i === hyperMark.endIndex) {
                    (0, util_1.addHyperToken)(status, i, hyperMark, hyperMark.endValue, types_1.MarkSideType.RIGHT);
                    i += hyperMark.endValue.length - 1;
                }
            }
        }
        else if (type === types_1.CharType.SPACE) {
            // end the last unfinished token
            // jump to the next non-space char
            // record the last space
            // - space after a token
            // - inner space before a group
            (0, util_1.finalizeLastToken)(status, i);
            if (status.lastGroup) {
                const spaceLength = (0, util_1.getConnectingSpaceLength)(str, i);
                const spaces = str.substring(i, i + spaceLength);
                if (status.lastGroup.length) {
                    const lastToken = (0, util_1.getPreviousToken)(status);
                    if (lastToken) {
                        lastToken.spaceAfter = spaces;
                    }
                }
                else {
                    status.lastGroup.innerSpaceBefore = spaces;
                }
                if (spaceLength - 1 > 0) {
                    i += spaceLength - 1;
                }
            }
        }
        else if ((0, util_1.isShorthand)(str, status, i, char)) {
            (0, util_1.appendValue)(status, char);
        }
        else if ((0, types_1.isPunctuationType)(type)) {
            (0, util_1.handlePunctuation)(i, char, type, status);
        }
        else if ((0, types_1.isLetterType)(type)) {
            (0, util_1.handleLetter)(i, char, type, status);
        }
        else if (type === types_1.CharType.EMPTY) {
            // Nothing
        }
        else {
            (0, util_1.handleLetter)(i, char, types_1.CharType.WESTERN_LETTER, status);
        }
    }
    (0, util_1.finalizeLastToken)(status, str.length);
    // handle all the unmatched parsing tokens
    (0, util_1.handleErrors)(status);
    return {
        tokens: status.tokens,
        groups: status.groups,
        marks: status.marks,
        errors: status.errors
    };
};
exports.parse = parse;
const toMutableToken = (token) => {
    if (Array.isArray(token)) {
        const mutableToken = token;
        mutableToken.modifiedType = token.type;
        mutableToken.modifiedValue = token.value;
        mutableToken.modifiedSpaceAfter = token.spaceAfter;
        mutableToken.modifiedStartValue = token.startValue;
        mutableToken.modifiedEndValue = token.endValue;
        mutableToken.modifiedInnerSpaceBefore = token.innerSpaceBefore;
        mutableToken.validations = [];
        token.forEach(toMutableToken);
        return mutableToken;
    }
    else {
        const mutableToken = token;
        mutableToken.modifiedType = token.type;
        mutableToken.modifiedValue = token.value;
        mutableToken.modifiedSpaceAfter = token.spaceAfter;
        mutableToken.validations = [];
        return mutableToken;
    }
};
const toMutableMark = (mark) => {
    const mutableMark = mark;
    mutableMark.modifiedStartValue = mark.startValue;
    mutableMark.modifiedEndValue = mark.endValue;
    return mutableMark;
};
const toMutableResult = (result, options = {}) => {
    if (!options.noSinglePair) {
        result.errors.length = 0;
    }
    toMutableToken(result.tokens);
    result.marks.forEach(toMutableMark);
    return result;
};
exports.toMutableResult = toMutableResult;
