"use strict";
/**
 * @fileoverview
 *
 * This rule will decide whether to keep a space outside inline code with
 * content like:
 * - xxx `foo` xxx
 * - xxx <code>foo</code> xxx
 * in markdown/html.
 *
 * Options:
 * - spaceOutsideCode: boolean | undefined
 *   - `true`: keep one space outside (default)
 *   - `false`: no space outside
 *   - `undefined`: do nothing, just keep the original format
 *
 * Details:
 * - code x code
 * - content x code
 * - code x content
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultConfig = void 0;
const util_1 = require("./util");
const parser_1 = require("../parser");
const messages_1 = require("./messages");
const generateHandler = (options) => {
    const needSpaceOption = options === null || options === void 0 ? void 0 : options.spaceOutsideCode;
    const spaceAfter = needSpaceOption ? ' ' : '';
    const message = needSpaceOption ? messages_1.CODE_SPACE_OUTSIDE : messages_1.CODE_NOSPACE_OUTSIDE;
    const handleHyperSpaceOption = (token, _, group) => {
        // skip if there is no options
        if (typeof needSpaceOption === 'undefined') {
            return;
        }
        // skip non-code tokens
        if (token.type !== parser_1.HyperTokenType.CODE_CONTENT) {
            return;
        }
        // skip non-after-token situations
        const contentTokenBefore = (0, util_1.findVisibleTokenBefore)(group, token);
        const contentTokenAfter = (0, util_1.findVisibleTokenAfter)(group, token);
        const { spaceHost: beforeSpaceHost } = (0, util_1.findWrappersBetween)(group, contentTokenBefore, token);
        const { spaceHost: afterSpaceHost } = (0, util_1.findWrappersBetween)(group, token, contentTokenAfter);
        // content x code
        if (contentTokenBefore && (0, parser_1.isLetterType)(contentTokenBefore.type)) {
            beforeSpaceHost && (0, util_1.checkSpaceAfter)(beforeSpaceHost, spaceAfter, message);
        }
        // code x content or code x code
        if (contentTokenAfter &&
            ((0, parser_1.isLetterType)(contentTokenAfter.type) ||
                contentTokenAfter.type === parser_1.HyperTokenType.CODE_CONTENT)) {
            afterSpaceHost && (0, util_1.checkSpaceAfter)(afterSpaceHost, spaceAfter, message);
        }
    };
    return handleHyperSpaceOption;
};
exports.defaultConfig = {
    spaceOutsideCode: true
};
exports.default = generateHandler;
