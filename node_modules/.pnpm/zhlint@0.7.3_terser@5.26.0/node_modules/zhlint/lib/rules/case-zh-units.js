"use strict";
/**
 * @fileoverview
 *
 * This rule is used to revert changes of spaceAfter between numbers and
 * Chinese units.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultConfig = void 0;
const parser_1 = require("../parser");
const report_1 = require("../report");
const util_1 = require("./util");
const defaultSkippedZhUnits = `年月日天号时分秒`;
const generateHandler = (options) => {
    const skippedZhUnits = (options === null || options === void 0 ? void 0 : options.skipZhUnits) || '';
    const matcherStr = skippedZhUnits
        .split('')
        .filter((x) => (0, parser_1.checkCharType)(x) === parser_1.CharType.CJK_CHAR)
        .join('');
    const unitMatcher = new RegExp(`^[${matcherStr}]`);
    return (token, _, group) => {
        // make sure the value is a number
        if (token.type === parser_1.CharType.WESTERN_LETTER && token.value.match(/^\d+$/)) {
            // make sure the value after is a Chinese unit
            const tokenAfter = (0, util_1.findNonCodeVisibleTokenAfter)(group, token);
            if (Array.isArray(tokenAfter))
                return;
            if (tokenAfter && tokenAfter.value.match(unitMatcher)) {
                // make sure there is no space between originally
                const { spaceHost: spaceHostAfter, tokens: tokenSeqAfter } = (0, util_1.findWrappersBetween)(group, token, tokenAfter);
                const hasSpaceAfterOriginally = tokenSeqAfter.some((x) => x.spaceAfter);
                if (hasSpaceAfterOriginally) {
                    return;
                }
                // if any token before
                const tokenBefore = (0, util_1.findNonCodeVisibleTokenBefore)(group, token);
                if (tokenBefore) {
                    // make sure there is no space between originally
                    const { spaceHost: spaceHostBefore, tokens: tokenSeqBefore } = (0, util_1.findWrappersBetween)(group, tokenBefore, token);
                    const hasSpaceBeforeOriginally = tokenSeqBefore.some((x) => x.spaceAfter);
                    if (hasSpaceBeforeOriginally) {
                        return;
                    }
                    // revert non-space before
                    if (spaceHostBefore) {
                        spaceHostBefore.modifiedSpaceAfter = '';
                        (0, util_1.removeValidationOnTarget)(spaceHostBefore, report_1.ValidationTarget.SPACE_AFTER);
                    }
                }
                // revert non-space after
                if (spaceHostAfter) {
                    spaceHostAfter.modifiedSpaceAfter = '';
                    (0, util_1.removeValidationOnTarget)(spaceHostAfter, report_1.ValidationTarget.SPACE_AFTER);
                }
            }
        }
    };
};
exports.defaultConfig = {
    skipZhUnits: defaultSkippedZhUnits
};
exports.default = generateHandler;
