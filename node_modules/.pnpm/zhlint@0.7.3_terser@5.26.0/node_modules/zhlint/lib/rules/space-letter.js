"use strict";
/**
 * @fileoverview
 *
 * This rule is used to check whether there should be a space between
 * content.
 *
 * Options:
 * - spaceBetweenHalfwidthContent: boolean | undefined
 *   - `true`: ensure one space between half-width content (default)
 *   - `false` or `undefined`: do nothing, just keep the original format
 * - noSpaceBetweenFullwidthContent: boolean | undefined
 *   - `true`: remove the space between full-width content (default)
 *   - `false` or `undefined`: do nothing, just keep the original format
 * - spaceBetweenMixedwidthContent: boolean | undefined
 *   - `true`: keep one space between width-mixed content (default)
 *   - `false`: no space between width-mixed content
 *   - `undefined`: do nothing, just keep the original format
 *
 * Examples (betweenMixedWidthContent = true):
 * - *a*啊 -> *a* 啊
 * - *a *啊 -> *a* 啊
 * - *啊*a -> *啊* a
 * - *啊 *a -> *啊* a
 *
 * Examples (betweenMixedWidthContent = false):
 * - *a* 啊 -> *a*啊
 * - *a *啊 -> *a*啊
 * - *啊* a -> *啊*a
 * - *啊 *a -> *啊*a
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultConfig = void 0;
const parser_1 = require("../parser");
const util_1 = require("./util");
const messages_1 = require("./messages");
const generateHandler = (options) => {
    const onlyOneBetweenHalfwidthContentOption = options === null || options === void 0 ? void 0 : options.spaceBetweenHalfwidthContent;
    const noBetweenFullwidthContentOption = options === null || options === void 0 ? void 0 : options.noSpaceBetweenFullwidthContent;
    const betweenMixedwidthContentOption = options === null || options === void 0 ? void 0 : options.spaceBetweenMixedwidthContent;
    return (token, _, group) => {
        // skip non-content tokens
        if (!(0, parser_1.isLetterType)(token.type)) {
            return;
        }
        // skip non-content after-tokens
        const contentTokenAfter = (0, util_1.findVisibleTokenAfter)(group, token);
        if (!contentTokenAfter || !(0, parser_1.isLetterType)(contentTokenAfter.type)) {
            return;
        }
        // find the space host
        const { spaceHost, tokens } = (0, util_1.findWrappersBetween)(group, token, contentTokenAfter);
        // skip if the space host is not found
        if (!spaceHost) {
            return;
        }
        // 1. half x half, full x full
        // 2. half x full, full x half
        if (contentTokenAfter.type === token.type) {
            // skip without custom option
            if (token.type === parser_1.CharType.WESTERN_LETTER) {
                if (!onlyOneBetweenHalfwidthContentOption) {
                    return;
                }
                // skip if half-content x marks x half-content
                if (tokens.length > 1 &&
                    tokens.filter((token) => token.spaceAfter).length === 0) {
                    return;
                }
            }
            else {
                if (!noBetweenFullwidthContentOption) {
                    return;
                }
            }
            const spaceAfter = token.type === parser_1.CharType.WESTERN_LETTER ? ' ' : '';
            const message = token.type === parser_1.CharType.WESTERN_LETTER
                ? messages_1.CONTENT_SPACE_HALF_WIDTH
                : messages_1.CONTENT_NOSPACE_FULL_WIDTH;
            (0, util_1.checkSpaceAfter)(spaceHost, spaceAfter, message);
        }
        else {
            // skip without custom option
            if (typeof betweenMixedwidthContentOption === 'undefined') {
                return;
            }
            const spaceAfter = betweenMixedwidthContentOption ? ' ' : '';
            const message = betweenMixedwidthContentOption
                ? messages_1.CONTENT_SPACE_MIXED_WIDTH
                : messages_1.CONTENT_NOSPACE_MIXED_WIDTH;
            (0, util_1.checkSpaceAfter)(spaceHost, spaceAfter, message);
        }
    };
};
exports.defaultConfig = {
    spaceBetweenHalfWidthContent: true,
    noSpaceBetweenFullWidthContent: true,
    spaceBetweenMixedWidthContent: true
};
exports.default = generateHandler;
