"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkValue = exports.checkInnerSpaceBefore = exports.checkEndValue = exports.checkStartValue = exports.checkSpaceAfter = exports.removeValidationOnTarget = exports.hasValidationOnTarget = exports.setValidationOnTarget = exports.isSuccessiveHalfwidthPunctuation = exports.isHalfwidthPunctuationWithoutSpaceAround = exports.findWrappersBetween = exports.findConnectedWrappers = exports.getWrapperSide = exports.isWrapper = exports.findVisibleTokenAfter = exports.findVisibleTokenBefore = exports.findNonCodeVisibleTokenAfter = exports.findNonCodeVisibleTokenBefore = exports.findTokenAfter = exports.findTokenBefore = void 0;
const report_1 = require("../report");
const parser_1 = require("../parser");
// find tokens
/**
 * Find the previous token if exists
 */
const findTokenBefore = (group, token) => {
    if (!token) {
        return;
    }
    const index = group.indexOf(token);
    if (index < 0) {
        return;
    }
    return group[index - 1];
};
exports.findTokenBefore = findTokenBefore;
/**
 * Find the next token if exists
 */
const findTokenAfter = (group, token) => {
    if (!token) {
        return;
    }
    const index = group.indexOf(token);
    if (index < 0) {
        return;
    }
    return group[index + 1];
};
exports.findTokenAfter = findTokenAfter;
/**
 * Find a certain token before, which:
 * - group, content, punctuation, and bracket will be passed
 * - code, container, and unknown will be failed
 * - hyper mark, html pairs will be skipped
 */
const findNonCodeVisibleTokenBefore = (group, token) => {
    if (!token) {
        return;
    }
    const beforeToken = (0, exports.findTokenBefore)(group, token);
    if (!beforeToken) {
        return;
    }
    // hyper mark, html pairs: skip
    if ((0, parser_1.isInvisibleType)(beforeToken.type) || getHtmlTagSide(beforeToken)) {
        return (0, exports.findNonCodeVisibleTokenBefore)(group, beforeToken);
    }
    // content, punctuation, bracket, group: return token
    if ((0, parser_1.isNonCodeVisibleType)(beforeToken.type)) {
        return beforeToken;
    }
    // code, unknown, container: return undefined
    return;
};
exports.findNonCodeVisibleTokenBefore = findNonCodeVisibleTokenBefore;
/**
 * Find a certain token after, which:
 * - group, content, punctuation, and bracket will be passed
 * - code, container, and unknown will be failed
 * - hyper mark, html pairs will be skipped
 */
const findNonCodeVisibleTokenAfter = (group, token) => {
    if (!token) {
        return;
    }
    const afterToken = (0, exports.findTokenAfter)(group, token);
    if (!afterToken) {
        return;
    }
    // hyper mark, html pairs: skip
    if ((0, parser_1.isInvisibleType)(afterToken.type) || getHtmlTagSide(afterToken)) {
        return (0, exports.findNonCodeVisibleTokenAfter)(group, afterToken);
    }
    // content, punctuation, bracket, group: return token
    if ((0, parser_1.isNonCodeVisibleType)(afterToken.type)) {
        return afterToken;
    }
    // code, unknown, container: return undefined
    return;
};
exports.findNonCodeVisibleTokenAfter = findNonCodeVisibleTokenAfter;
/**
 * Find a certain token before, which:
 * - group, content, punctuation, bracket, and code will be passed
 * - container, and unknown will be failed
 * - hyper mark, html pairs will be skipped
 */
const findVisibleTokenBefore = (group, token) => {
    if (!token) {
        return;
    }
    const beforeToken = (0, exports.findTokenBefore)(group, token);
    if (!beforeToken) {
        return;
    }
    // hyper mark, html pairs: skip
    if ((0, parser_1.isInvisibleType)(beforeToken.type) || getHtmlTagSide(beforeToken)) {
        return (0, exports.findVisibleTokenBefore)(group, beforeToken);
    }
    // content, punctuation, bracket, group, code: return token
    if ((0, parser_1.isVisibleType)(beforeToken.type)) {
        return beforeToken;
    }
    // unknown, container: return undefined
    return;
};
exports.findVisibleTokenBefore = findVisibleTokenBefore;
/**
 * Find a certain token after, which:
 * - group, content, punctuation, bracket, and code will be passed
 * - container, and unknown will be failed
 * - hyper mark, html pairs will be skipped
 */
const findVisibleTokenAfter = (group, token) => {
    if (!token) {
        return;
    }
    const afterToken = (0, exports.findTokenAfter)(group, token);
    if (!afterToken) {
        return;
    }
    // hyper mark, html pairs: skip
    if ((0, parser_1.isInvisibleType)(afterToken.type) || getHtmlTagSide(afterToken)) {
        return (0, exports.findVisibleTokenAfter)(group, afterToken);
    }
    // content, punctuation, bracket, group, code: return token
    if ((0, parser_1.isVisibleType)(afterToken.type)) {
        return afterToken;
    }
    // unknown, container: return undefined
    return;
};
exports.findVisibleTokenAfter = findVisibleTokenAfter;
// hyper mark seq
const isHtmlTag = (token) => {
    if (token.type !== parser_1.HyperTokenType.HYPER_CONTENT) {
        return false;
    }
    return !!token.value.match(/^<.+>$/);
};
const getHtmlTagSide = (token) => {
    if (!isHtmlTag(token)) {
        return;
    }
    if (token.value.match(/^<code.*>.*<\/code.*>$/)) {
        return;
    }
    if (token.value.match(/^<[^/].+\/\s*>$/)) {
        return;
    }
    if (token.value.match(/^<[^/].+>$/)) {
        return parser_1.MarkSideType.LEFT;
    }
    if (token.value.match(/^<\/.+>$/)) {
        return parser_1.MarkSideType.RIGHT;
    }
};
const isWrapper = (token) => {
    return token.type === parser_1.HyperTokenType.HYPER_MARK || !!getHtmlTagSide(token);
};
exports.isWrapper = isWrapper;
const getWrapperSide = (token) => {
    if (token.type === parser_1.HyperTokenType.HYPER_MARK) {
        return token.markSide;
    }
    return getHtmlTagSide(token);
};
exports.getWrapperSide = getWrapperSide;
const spreadHyperMarkSeq = (group, token, seq, isBackward) => {
    if (isBackward) {
        const tokenBefore = (0, exports.findTokenBefore)(group, token);
        if (tokenBefore && (0, exports.isWrapper)(tokenBefore)) {
            seq.unshift(tokenBefore);
            spreadHyperMarkSeq(group, tokenBefore, seq, isBackward);
        }
    }
    else {
        const tokenAfter = (0, exports.findTokenAfter)(group, token);
        if (tokenAfter && (0, exports.isWrapper)(tokenAfter)) {
            seq.push(tokenAfter);
            spreadHyperMarkSeq(group, tokenAfter, seq, isBackward);
        }
    }
};
const findConnectedWrappers = (group, token) => {
    const seq = [token];
    spreadHyperMarkSeq(group, token, seq, false);
    spreadHyperMarkSeq(group, token, seq, true);
    return seq;
};
exports.findConnectedWrappers = findConnectedWrappers;
const findSpaceHostInHyperMarkSeq = (group, hyperMarkSeq) => {
    // Return nothing if the seq is empty
    if (!hyperMarkSeq.length) {
        return;
    }
    const firstMark = hyperMarkSeq[0];
    const lastMark = hyperMarkSeq[hyperMarkSeq.length - 1];
    const firstMarkSide = (0, exports.getWrapperSide)(firstMark);
    const lastMarkSide = (0, exports.getWrapperSide)(lastMark);
    const tokenBefore = (0, exports.findTokenBefore)(group, firstMark);
    if (!tokenBefore) {
        return;
    }
    // Return nothing if any token is not a mark.
    if (!firstMarkSide || !lastMarkSide) {
        return;
    }
    // If first and last mark have the same side, then return:
    // - token before first mark if they are the left side
    // - last mark if they are the right side
    if (firstMarkSide === lastMarkSide) {
        if (firstMarkSide === parser_1.MarkSideType.LEFT) {
            return tokenBefore;
        }
        return lastMark;
    }
    // If first mark is the left side and last mark is the right side,
    // that usually means multiple marks partially overlapped.
    // This situation is abnormal but technically exists.
    // We'd better do nothing and leave this issue to human.
    if (firstMarkSide === parser_1.MarkSideType.LEFT) {
        return;
    }
    // If first mark is the right side and last mark is the left side,
    // that usually means multiple marks closely near eath other.
    // We'd better find the gap outside the both sides of marks.
    let target = tokenBefore;
    while (target && target !== lastMark) {
        const nextToken = (0, exports.findTokenAfter)(group, target);
        if (nextToken && (0, exports.getWrapperSide)(nextToken) === parser_1.MarkSideType.LEFT) {
            return target;
        }
        target = nextToken;
    }
    return tokenBefore;
};
const findWrappersBetween = (group, before, after) => {
    if (!before || !after) {
        return {
            spaceHost: undefined,
            wrappers: [],
            tokens: []
        };
    }
    const firstMark = (0, exports.findTokenAfter)(group, before);
    const firstVisible = (0, exports.findVisibleTokenAfter)(group, before);
    if (!firstMark || firstVisible !== after) {
        return {
            spaceHost: undefined,
            wrappers: [],
            tokens: []
        };
    }
    if (firstMark === after) {
        return {
            spaceHost: before,
            wrappers: [],
            tokens: [before]
        };
    }
    const markSeq = (0, exports.findConnectedWrappers)(group, firstMark);
    const spaceHost = findSpaceHostInHyperMarkSeq(group, markSeq);
    return {
        spaceHost,
        wrappers: markSeq,
        tokens: [before, ...markSeq]
    };
};
exports.findWrappersBetween = findWrappersBetween;
// special cases
const isHalfwidthPunctuationWithoutSpaceAround = (group, token) => {
    const tokenBefore = (0, exports.findTokenBefore)(group, token);
    const tokenAfter = (0, exports.findTokenAfter)(group, token);
    if ((0, parser_1.isHalfwidthPunctuationType)(token.type) &&
        tokenBefore &&
        tokenBefore.type === parser_1.CharType.WESTERN_LETTER &&
        tokenAfter &&
        tokenAfter.type === parser_1.CharType.WESTERN_LETTER) {
        return !tokenBefore.spaceAfter && !token.spaceAfter;
    }
    return false;
};
exports.isHalfwidthPunctuationWithoutSpaceAround = isHalfwidthPunctuationWithoutSpaceAround;
const isSuccessiveHalfwidthPunctuation = (group, token) => {
    if ((0, parser_1.isHalfwidthPunctuationType)(token.type)) {
        const tokenBefore = (0, exports.findTokenBefore)(group, token);
        const tokenAfter = (0, exports.findTokenAfter)(group, token);
        if ((tokenBefore &&
            (0, parser_1.isHalfwidthPunctuationType)(tokenBefore.type) &&
            !tokenBefore.spaceAfter) ||
            (tokenAfter &&
                (0, parser_1.isHalfwidthPunctuationType)(tokenAfter.type) &&
                !token.spaceAfter)) {
            return true;
        }
    }
    return false;
};
exports.isSuccessiveHalfwidthPunctuation = isSuccessiveHalfwidthPunctuation;
// validations helpers
const createValidation = (token, target, message, name) => {
    const validation = {
        index: token.index,
        length: token.length,
        target,
        name,
        message
    };
    if (target === report_1.ValidationTarget.START_VALUE) {
        validation.index = token.startIndex;
        validation.length = 0;
    }
    else if (target === report_1.ValidationTarget.END_VALUE) {
        validation.index = token.endIndex;
        validation.length = 0;
    }
    else if (target === report_1.ValidationTarget.INNER_SPACE_BEFORE) {
        validation.index = token.startIndex;
        validation.length = token.startValue.length;
    }
    return validation;
};
const setValidationOnTarget = (token, target, message, name) => {
    const validation = createValidation(token, target, message, name);
    (0, exports.removeValidationOnTarget)(token, target);
    token.validations.push(validation);
};
exports.setValidationOnTarget = setValidationOnTarget;
const hasValidationOnTarget = (token, target) => {
    return token.validations.some((validation) => validation.target === target);
};
exports.hasValidationOnTarget = hasValidationOnTarget;
const removeValidationOnTarget = (token, target) => {
    token.validations = token.validations.filter((validation) => validation.target !== target);
};
exports.removeValidationOnTarget = removeValidationOnTarget;
const genChecker = (key, target) => {
    return (token, value, message) => {
        if (token[key] !== value) {
            token[key] = value;
            (0, exports.setValidationOnTarget)(token, target, message, '');
        }
    };
};
exports.checkSpaceAfter = genChecker('modifiedSpaceAfter', report_1.ValidationTarget.SPACE_AFTER);
exports.checkStartValue = genChecker('modifiedStartValue', report_1.ValidationTarget.START_VALUE);
exports.checkEndValue = genChecker('modifiedEndValue', report_1.ValidationTarget.END_VALUE);
exports.checkInnerSpaceBefore = genChecker('modifiedInnerSpaceBefore', report_1.ValidationTarget.INNER_SPACE_BEFORE);
const checkValue = (token, value, type, message) => {
    if (token.modifiedValue === value) {
        return;
    }
    token.modifiedValue = value;
    if (type) {
        token.modifiedType = type;
    }
    (0, exports.setValidationOnTarget)(token, report_1.ValidationTarget.VALUE, message, '');
};
exports.checkValue = checkValue;
