"use strict";
/**
 * @fileoverview
 *
 * This rule is checking spaces besides normal punctuations.
 * Usually, for full-width punctuations, we don't need any spaces around.
 * For half-width punctuations, we need a space after that.
 *
 * Options
 * - noSpaceBeforePunctuation: boolean | undefined
 *   - `true`: remove spaces before a half-width punctuation (default)
 *   - `false` or `undefined`: do nothing, just keep the original format
 * - spaceAfterHalfWidthPunctuation: boolean | undefined
 *   - `true`: ensure one space after a half-width punctuation (default)
 *   - `false` or `undefined`: do nothing, just keep the original format
 * - noSpaceAfterFullWidthPunctuation: boolean | undefined
 *   - `true`: remove spaces around a full-width punctuation (default)
 *   - `false` or `undefined`: do nothing, just keep the original format
 *
 * Details:
 * - noSpaceBeforePunctuation:
 *   content/right-quote/right-bracket/code x punctuation
 * - spaceAfterHalfWidthPunctuation:
 *   half x content/left-quote/left-bracket/code
 * - noSpaceAfterFullWidthPunctuation:
 *   full x content/left-quote/left-bracket/code
 *
 * - skip half-width punctuations between half-width content without space
 * - skip successive multiple half-width punctuations
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultConfig = void 0;
const parser_1 = require("../parser");
const util_1 = require("./util");
const messages_1 = require("./messages");
const generateHandler = (options) => {
    const noBeforePunctuationOption = options === null || options === void 0 ? void 0 : options.noSpaceBeforePauseOrStop;
    const oneAfterHalfWidthPunctuationOption = options === null || options === void 0 ? void 0 : options.spaceAfterHalfwidthPauseOrStop;
    const noAfterFullWidthPunctuationOption = options === null || options === void 0 ? void 0 : options.noSpaceAfterFullwidthPauseOrStop;
    return (token, _, group) => {
        // skip non-punctuation tokens and non-normal punctuations
        if (!(0, parser_1.isPauseOrStopType)(token.type)) {
            return;
        }
        // skip half-width punctuations between half-width content without space
        if ((0, util_1.isHalfwidthPunctuationWithoutSpaceAround)(group, token)) {
            return;
        }
        // skip successive multiple half-width punctuations
        if ((0, util_1.isSuccessiveHalfwidthPunctuation)(group, token)) {
            return;
        }
        // 1. content/right-quotation/right-bracket/code x punctuation
        if (noBeforePunctuationOption) {
            const contentTokenBefore = (0, util_1.findVisibleTokenBefore)(group, token);
            if (contentTokenBefore &&
                // content
                ((0, parser_1.isLetterType)(contentTokenBefore.type) ||
                    // right-quotation
                    contentTokenBefore.type === parser_1.GroupTokenType.GROUP ||
                    // right-bracket
                    (contentTokenBefore.type === parser_1.HyperTokenType.BRACKET_MARK &&
                        contentTokenBefore.markSide === parser_1.MarkSideType.RIGHT) ||
                    // code
                    contentTokenBefore.type === parser_1.HyperTokenType.CODE_CONTENT)) {
                const { spaceHost } = (0, util_1.findWrappersBetween)(group, contentTokenBefore, token);
                if (spaceHost) {
                    (0, util_1.checkSpaceAfter)(spaceHost, '', messages_1.PUNCTUATION_NOSPACE_BEFORE);
                }
            }
        }
        // 2. half/full x content/left-quotation/left-bracket/code
        if (((0, parser_1.isFullwidthPunctuationType)(token.modifiedType) &&
            noAfterFullWidthPunctuationOption) ||
            ((0, parser_1.isHalfwidthPunctuationType)(token.modifiedType) &&
                oneAfterHalfWidthPunctuationOption)) {
            const spaceAfter = (0, parser_1.isHalfwidthPunctuationType)(token.modifiedType)
                ? ' '
                : '';
            const message = (0, parser_1.isHalfwidthPunctuationType)(token.modifiedType)
                ? messages_1.PUNCTUATION_SPACE_AFTER
                : messages_1.PUNCTUATION_NOSPACE_AFTER;
            const contentTokenAfter = (0, util_1.findVisibleTokenAfter)(group, token);
            if (contentTokenAfter &&
                // content
                ((0, parser_1.isLetterType)(contentTokenAfter.type) ||
                    // left-quotation
                    contentTokenAfter.type === parser_1.GroupTokenType.GROUP ||
                    // left-bracket
                    (contentTokenAfter.type === parser_1.HyperTokenType.BRACKET_MARK &&
                        contentTokenAfter.markSide === parser_1.MarkSideType.LEFT) ||
                    // code
                    contentTokenAfter.type === parser_1.HyperTokenType.CODE_CONTENT)) {
                const { spaceHost } = (0, util_1.findWrappersBetween)(group, token, contentTokenAfter);
                if (spaceHost) {
                    (0, util_1.checkSpaceAfter)(spaceHost, spaceAfter, message);
                }
            }
        }
    };
};
exports.defaultConfig = {
    noSpaceBeforePunctuation: true,
    spaceAfterHalfWidthPunctuation: true,
    noSpaceAfterFullWidthPunctuation: true
};
exports.default = generateHandler;
