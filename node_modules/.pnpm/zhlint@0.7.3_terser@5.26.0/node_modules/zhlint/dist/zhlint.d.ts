export declare type Block = {
    value: string
    marks: Mark[]
    start: number
    end: number
}

declare enum CharType {
    EMPTY = 'empty',

    SPACE = 'space',

    WESTERN_LETTER = 'western-letter',
    CJK_CHAR = 'cjk-char',

    // periods, commas, secondary commas, colons, semicolons, exclamation marks, question marks, etc.
    HALFWIDTH_PAUSE_OR_STOP = 'halfwidth-pause-or-stop',
    FULLWIDTH_PAUSE_OR_STOP = 'fullwidth-pause-or-stop',

    // single, double, corner, white corner
    // + book title marks
    // left x right
    HALFWIDTH_QUOTATION = 'halfwidth-quotation',
    FULLWIDTH_QUOTATION = 'fullwidth-quotation',

    // parentheses
    HALFWIDTH_BRACKET = 'halfwidth-bracket',
    FULLWIDTH_BRACKET = 'fullwidth-bracket',

    // // parenthesis, black lenticular brackets, white lenticular brackets,
    // // square brackets, tortoise shell brackets, curly brackets
    // // left x right
    // PARENTHESIS = 'parenthesis',
    // // double angle brackets, angle brackets
    // // left x right
    // BOOK_TITLE_MARK = 'book-title',

    // dashes, ellipsis, connector marks, interpuncts, proper noun marks, solidi, etc.
    HALFWIDTH_OTHER_PUNCTUATION = 'halfwidth-other-punctuation',
    FULLWIDTH_OTHER_PUNCTUATION = 'fullwidth-other-punctuation',

    // // ⁈, ⁇, ‼, ⁉
    // SPECIAL_PUNCTUATION_MARK = 'special-punctuation',

    UNKNOWN = 'unknown'
}

declare type CommonToken = {
    index: number
    length: number

    value: string
    spaceAfter: string

    mark?: Mark
    markSide?: MarkSideType
}

declare type Config = {
    preset?: string
    rules?: Options['rules']
    hyperParsers?: string[]
    ignores?: string[]
}

declare type DebugInfo = {
    pieces: Piece[]
    blocks: ParsedBlock[]
    ignoredCases: IgnoredCase[]
    ignoredByParsers: ParserIgnoredCase[]
    ignoredTokens: MutableToken[]
    parserErrors: Validation[]
    ruleErrors: Validation[]
    ignoredRuleErrors: Validation[]
}

declare type DeprecatedOptions = {
    // punctuation
    /**
     * @deprecated
     *
     * Please use `halfwidthPunctuation` instead.
     */
    halfWidthPunctuation?: string
    /**
     * @deprecated
     *
     * Please use `fullwidthPunctuation` instead.
     */
    fullWidthPunctuation?: string
    /**
     * @deprecated
     *
     * Please use `adjustedFullwidthPunctuation` instead.
     */
    adjustedFullWidthPunctuation?: string

    // space around content
    /**
     * @deprecated
     *
     * Please use `spaceBetweenHalfwidthContent` instead.
     */
    spaceBetweenHalfWidthLetters?: boolean
    /**
     * @deprecated
     *
     * Please use `spaceBetweenHalfwidthContent` instead.
     */
    spaceBetweenHalfWidthContent?: boolean
    /**
     * @deprecated
     *
     * Please use `noSpaceBetweenFullwidthContent` instead.
     */
    noSpaceBetweenFullWidthLetters?: boolean
    /**
     * @deprecated
     *
     * Please use `noSpaceBetweenFullwidthContent` instead.
     */
    noSpaceBetweenFullWidthContent?: boolean
    /**
     * @deprecated
     *
     * Please use `spaceBetweenMixedwidthContent` instead.
     */
    spaceBetweenMixedWidthLetters?: boolean
    /**
     * @deprecated
     *
     * Please use `spaceBetweenMixedwidthContent` instead.
     */
    spaceBetweenMixedWidthContent?: boolean

    // space around punctuation
    /**
     * @deprecated
     *
     * Please use `noSpaceBeforePauseOrStop` instead.
     */
    noSpaceBeforePunctuation?: boolean
    /**
     * @deprecated
     *
     * Please use `spaceAfterHalfwidthPauseOrStop` instead.
     */
    spaceAfterHalfWidthPunctuation?: boolean
    /**
     * @deprecated
     *
     * Please use `noSpaceAfterFullwidthPauseOrStop` instead.
     */
    noSpaceAfterFullWidthPunctuation?: boolean

    // space around quotation
    /**
     * @deprecated
     *
     * Please use `spaceOutsideHalfwidthQuotation` instead.
     */
    spaceOutsideHalfQuote?: boolean
    /**
     * @deprecated
     *
     * Please use `noSpaceOutsideFullwidthQuotation` instead.
     */
    noSpaceOutsideFullQuote?: boolean
    /**
     * @deprecated
     *
     * Please use `noSpaceInsideQuotation` instead.
     */
    noSpaceInsideQuote?: boolean

    // space around bracket
    /**
     * @deprecated
     *
     * Please use `spaceOutsideHalfwidthBracket` instead.
     */
    spaceOutsideHalfBracket?: boolean
    /**
     * @deprecated
     *
     * Please use `noSpaceOutsideFullwidthBracket` instead.
     */
    noSpaceOutsideFullBracket?: boolean

    // space around mark
    /**
     * @deprecated
     *
     * Please use `noSpaceInsideHyperMark` instead.
     */
    noSpaceInsideWrapper?: boolean
    /**
     * @deprecated
     *
     * Please use `noSpaceInsideHyperMark` instead.
     */
    noSpaceInsideMark?: boolean
}

export declare type GroupToken = Array<Token> &
CommonToken &
Pair & {
    type: GroupTokenType
    innerSpaceBefore: string
}

export declare enum GroupTokenType {
    GROUP = 'group'
}

export declare type Handler = (
token: MutableToken | Token,
index: number,
group: MutableGroupToken | GroupToken
) => void

/**
 * TODO: paired html tags should be hyper mark
 */
declare enum HyperTokenType {
    /**
     * Brackets
     */
    BRACKET_MARK = 'bracket-mark',
    /**
     * Inline Markdown marks
     */
    HYPER_MARK = 'hyper-mark',

    /**
     * - \`xxx\`
     * - &lt;code&gt;xxx&lt;/code&gt;
     */
    CODE_CONTENT = 'code-content',
    /**
     * - Hexo/VuePress container
     * - Other html code
     */
    HYPER_CONTENT = 'hyper-content',

    /**
     * Unpaired brackets/quotations
     */
    UNMATCHED = 'unmatched',
    /**
     * For indeterminate tokens
     */
    INDETERMINATED = 'indeterminated'
}

export declare type IgnoredCase = {
    prefix?: string
    textStart: string
    textEnd?: string
    suffix?: string
}

declare type LetterType = CharType.WESTERN_LETTER | CharType.CJK_CHAR

export declare type Mark = Pair & {
    type: MarkType
    meta?: string // TODO: AST type enum
}

declare enum MarkSideType {
    LEFT = 'left',
    RIGHT = 'right'
}

/**
 * Marks are hyper info, including content and wrappers.
 * They are categorized by parsers, not by usage.
 */
export declare enum MarkType {
    /**
     * Brackets
     */
    BRACKETS = 'brackets',
    /**
     * Inline Markdown marks
     */
    HYPER = 'hyper',
    /**
     * - \`xxx\`
     * - &lt;code&gt;xxx&lt;/code&gt;
     * - Hexo/VuePress container
     * - Other html code
     */
    RAW = 'raw'
}

declare type MutableCommonToken = CommonToken & {
    modifiedValue: string
    ignoredValue?: string
    modifiedSpaceAfter: string
    ignoredSpaceAfter?: string
    validations: Validation[]
}

declare type MutableGroupToken = Array<MutableToken> &
MutableCommonToken &
Pair &
MutablePair & {
    type: GroupTokenType
    modifiedType: GroupTokenType
    ignoredType?: GroupTokenType
    innerSpaceBefore: string
    modifiedInnerSpaceBefore: string
    ignoredInnerSpaceBefore?: string
}

declare type MutableMark = Mark & MutablePair

declare type MutablePair = {
    modifiedStartValue: string
    ignoredStartValue?: string
    modifiedEndValue: string
    ignoredEndValue?: string
}

declare type MutableParseResult = {
    tokens: MutableGroupToken
    groups: MutableGroupToken[]
    marks: MutableMark[]
    errors: Validation[]
}

declare type MutableSingleToken = MutableCommonToken & {
    type: SingleTokenType
    modifiedType: SingleTokenType
    ignoredType?: SingleTokenType
}

declare type MutableToken = MutableSingleToken | MutableGroupToken

declare type NonBlock = {
    nonBlock: true
    start: number
    end: number
    value: string
}

declare type NormalContentTokenType = LetterType | SinglePunctuationType

export declare type Options = {
    logger?: Console
    rules?: Options_2
    hyperParse?:
    | (string | ((status: ParsedStatus) => ParsedStatus))[]
    | ((status: ParsedStatus) => ParsedStatus)
    ignoredCases?: IgnoredCase[]
}

declare type Options_2 = {
    // parsing
    noSinglePair?: boolean

    // punctuation
    halfwidthPunctuation?: string
    fullwidthPunctuation?: string
    adjustedFullwidthPunctuation?: string
    unifiedPunctuation?:
    | 'traditional'
    | 'simplified'
    | (Record<string, boolean | string[]> & { default: boolean })

    // case: abbrs
    skipAbbrs?: string[]

    // space around content
    spaceBetweenHalfwidthContent?: boolean
    noSpaceBetweenFullwidthContent?: boolean
    spaceBetweenMixedwidthContent?: boolean

    // space around pause or stop punctuation
    noSpaceBeforePauseOrStop?: boolean
    spaceAfterHalfwidthPauseOrStop?: boolean
    noSpaceAfterFullwidthPauseOrStop?: boolean

    // space around quotation
    spaceOutsideHalfwidthQuotation?: boolean
    noSpaceOutsideFullwidthQuotation?: boolean
    noSpaceInsideQuotation?: boolean

    // space around bracket or book title mark
    spaceOutsideHalfwidthBracket?: boolean
    noSpaceOutsideFullwidthBracket?: boolean
    noSpaceInsideBracket?: boolean

    // space around code
    spaceOutsideCode?: boolean

    // space around mark
    noSpaceInsideHyperMark?: boolean

    // trim space
    trimSpace?: boolean

    // case: number x Chinese unit
    skipZhUnits?: string

    // custom preset
    preset?: string
} & DeprecatedOptions

declare type OtherPunctuationType =
| CharType.HALFWIDTH_OTHER_PUNCTUATION
| CharType.FULLWIDTH_OTHER_PUNCTUATION

declare type Pair = {
    startIndex: number
    startValue: string
    endIndex: number
    endValue: string
}

declare type ParsedBlock = Block &
MutableParseResult & {
    originValue: string
}

export declare type ParsedStatus = {
    value: string
    modifiedValue: string
    ignoredByRules: IgnoredCase[]
    ignoredByParsers: ParserIgnoredCase[]
    blocks: Block[]
}

export declare type ParserIgnoredCase = {
    name: string
    meta: string
    index: number
    length: number
    originValue: string
}

declare type PauseOrStopType =
| CharType.HALFWIDTH_PAUSE_OR_STOP
| CharType.FULLWIDTH_PAUSE_OR_STOP

declare type Piece = ParsedBlock | NonBlock

export declare const readRc: (
dir: string,
config: string,
ignore: string,
logger?: Console
) => Config;

export declare const report: (resultList: Result[], logger?: Console) => number;

export declare type Result = {
    file?: string
    disabled?: boolean
    origin: string
    result: string
    validations: Validation[]
    __debug__?: DebugInfo
}

export declare const run: (str: string, options?: Options) => Result;

export declare const runWithConfig: (str: string, config: Config) => Result;

declare type SinglePunctuationType = PauseOrStopType | OtherPunctuationType

export declare type SingleToken = CommonToken & {
    type: SingleTokenType
}

export declare type SingleTokenType = NormalContentTokenType | HyperTokenType

export declare type Token = SingleToken | GroupToken

export declare type Validation = {
    // the type and value of message
    name: string
    message: string

    // position of the token
    index: number
    length: number

    // which part of the token the error comes from
    target: ValidationTarget
}

export declare enum ValidationTarget {
    VALUE = 'value',
    START_VALUE = 'startValue',
    END_VALUE = 'endValue',
    SPACE_AFTER = 'spaceAfter',
    INNER_SPACE_BEFORE = 'innerSpaceBefore'
}

export { }
